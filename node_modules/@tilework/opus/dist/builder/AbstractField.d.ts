import type { HigherKindType, FieldDescendantStore } from './hkt';
import type { InlineFragment } from './InlineFragment';
export interface Argument {
    name: string;
    type: string;
    value: string;
}
export declare type FetchedFieldItemType = any;
export declare abstract class AbstractField<Name extends string, FieldReturnType, ArrayExpected extends boolean> {
    /**
     * Type of name is changeable by setting an alias onto it.
     * The actual value of name is immutable.
     */
    readonly name: Name;
    readonly isArray?: ArrayExpected;
    readonly tag: keyof FieldDescendantStore<any, any, any>;
    alias: string;
    children: Array<InlineFragment<any, any> | Field<any, any, any>>;
    args: Argument[];
    resultTypeHolder: FieldReturnType;
    calculators: Record<string, (result: FieldReturnType) => any>;
    transformer?: (result: FieldReturnType) => any;
    constructor(name: Name, isArray?: ArrayExpected);
    /**
     * This function will change type of the Field such way that it'll seem that the name has changed.
     * The name is immutable and therefore will not actually get changed.
     * This illusion is implemented so that you have proper typings for the queries' return values
     */
    setAlias<Alias extends string>(alias: Alias): HigherKindType<this['tag'], Alias, FieldReturnType, ArrayExpected>;
    addArgument(name: string, type: string, value: any): this;
    addCalculatedField<NewFieldName extends string, NewFieldType extends any>(field: NewFieldName, calculator: (result: FieldReturnType) => NewFieldType): HigherKindType<this['tag'], Name, FieldReturnType & {
        [k in NewFieldName]: NewFieldType;
    }, ArrayExpected>;
    addTransformation<RT>(transformer: (result: FieldReturnType) => RT): HigherKindType<this['tag'], Name, RT, ArrayExpected>;
    addField(arg: never): never;
    addField<NewFieldName extends string, IsArray extends boolean = false>(field: NewFieldName, isArray?: IsArray): HigherKindType<this['tag'], Name, FieldReturnType & {
        [k in NewFieldName]: IsArray extends true ? FetchedFieldItemType[] : FetchedFieldItemType;
    }, ArrayExpected>;
    addField<NewField extends InlineFragment<any, any>>(field: NewField): HigherKindType<this['tag'], Name, FieldReturnType & Partial<NewField['resultTypeHolder']>>;
    addField<F extends Field<any, any, any>>(field: F): HigherKindType<this['tag'], Name, FieldReturnType & {
        [k in F['name']]: F extends Field<any, any, true> ? F['resultTypeHolder'][] : F['resultTypeHolder'];
    }, ArrayExpected>;
    addFieldList<NewField extends string>(fieldList: readonly NewField[]): HigherKindType<this['tag'], Name, FieldReturnType & {
        [K in NewField]: FetchedFieldItemType;
    }, ArrayExpected>;
}
export declare class Field<Name extends string, FieldReturnType, IsArray extends boolean = false> extends AbstractField<Name, FieldReturnType, IsArray> {
    readonly tag = "Field";
}
