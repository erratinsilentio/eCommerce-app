declare enum GraphQlRequestType {
    Mutation = "mutation",
    Query = "query"
}
interface AccArgs {
    [name: string]: Array<[string, string]>;
}
interface GraphQLDocument {
    query: string;
    variables: {
        [name: string]: string;
    };
}
declare const prepareFieldString: (rootField: AbstractField<any, any, any>, accArgs?: AccArgs) => string;
declare const prepareRequest: (fields: AbstractField<any, any, any> | AbstractField<any, any, any>[], type: GraphQlRequestType) => GraphQLDocument;

interface IRequestable {
    readonly type: GraphQlRequestType;
}

declare class Query<Name extends string, FieldReturnType, IsArray extends boolean = false> extends AbstractField<Name, FieldReturnType, IsArray> implements IRequestable {
    readonly tag = "Query";
    readonly type = GraphQlRequestType.Query;
}

declare class InlineFragment<N extends string, RT> extends AbstractField<N, RT, false> {
    readonly tag = "InlineFragment";
    constructor(name: N);
}

interface FieldDescendantStore<N extends string, RT, A extends boolean> {
    Query: Query<N, RT, A>;
    Mutation: Mutation<N, RT, A>;
    Field: Field<N, RT, A>;
    AbstractField: AbstractField<N, RT, A>;
    InlineFragment: InlineFragment<N, RT>;
}
declare type HigherKindType<$ extends keyof FieldDescendantStore<any, any, any>, N extends string, RT, A extends boolean = false> = FieldDescendantStore<N, RT, A>[$];

interface Argument {
    name: string;
    type: string;
    value: string;
}
declare type FetchedFieldItemType = any;
declare abstract class AbstractField<Name extends string, FieldReturnType, ArrayExpected extends boolean> {
    /**
     * Type of name is changeable by setting an alias onto it.
     * The actual value of name is immutable.
     */
    readonly name: Name;
    readonly isArray?: ArrayExpected;
    readonly tag: keyof FieldDescendantStore<any, any, any>;
    alias: string;
    children: Array<InlineFragment<any, any> | Field<any, any, any>>;
    args: Argument[];
    resultTypeHolder: FieldReturnType;
    calculators: Record<string, (result: FieldReturnType) => any>;
    transformer?: (result: FieldReturnType) => any;
    constructor(name: Name, isArray?: ArrayExpected);
    /**
     * This function will change type of the Field such way that it'll seem that the name has changed.
     * The name is immutable and therefore will not actually get changed.
     * This illusion is implemented so that you have proper typings for the queries' return values
     */
    setAlias<Alias extends string>(alias: Alias): HigherKindType<this['tag'], Alias, FieldReturnType, ArrayExpected>;
    addArgument(name: string, type: string, value: any): this;
    addCalculatedField<NewFieldName extends string, NewFieldType extends any>(field: NewFieldName, calculator: (result: FieldReturnType) => NewFieldType): HigherKindType<this['tag'], Name, FieldReturnType & {
        [k in NewFieldName]: NewFieldType;
    }, ArrayExpected>;
    addTransformation<RT>(transformer: (result: FieldReturnType) => RT): HigherKindType<this['tag'], Name, RT, ArrayExpected>;
    addField(arg: never): never;
    addField<NewFieldName extends string, IsArray extends boolean = false>(field: NewFieldName, isArray?: IsArray): HigherKindType<this['tag'], Name, FieldReturnType & {
        [k in NewFieldName]: IsArray extends true ? FetchedFieldItemType[] : FetchedFieldItemType;
    }, ArrayExpected>;
    addField<NewField extends InlineFragment<any, any>>(field: NewField): HigherKindType<this['tag'], Name, FieldReturnType & Partial<NewField['resultTypeHolder']>>;
    addField<F extends Field<any, any, any>>(field: F): HigherKindType<this['tag'], Name, FieldReturnType & {
        [k in F['name']]: F extends Field<any, any, true> ? F['resultTypeHolder'][] : F['resultTypeHolder'];
    }, ArrayExpected>;
    addFieldList<NewField extends string>(fieldList: readonly NewField[]): HigherKindType<this['tag'], Name, FieldReturnType & {
        [K in NewField]: FetchedFieldItemType;
    }, ArrayExpected>;
}
declare class Field<Name extends string, FieldReturnType, IsArray extends boolean = false> extends AbstractField<Name, FieldReturnType, IsArray> {
    readonly tag = "Field";
}

declare class Mutation<Name extends string, FieldReturnType, IsArray extends boolean = false> extends AbstractField<Name, FieldReturnType, IsArray> implements IRequestable {
    readonly tag = "Mutation";
    readonly type = GraphQlRequestType.Mutation;
}

declare class CombinedField<ReturnType> {
    type?: GraphQlRequestType;
    resultTypeHolder?: ReturnType;
    protected fields: AbstractField<any, any, any>[];
    add<Name extends string, FieldReturnType, IsArray extends boolean>(field: Query<Name, FieldReturnType, IsArray> | Mutation<Name, FieldReturnType, IsArray>): CombinedField<ReturnType & {
        [k in Name]: IsArray extends true ? FieldReturnType[] : FieldReturnType;
    }>;
    getFields: () => AbstractField<any, any, any>[];
}

interface DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> {
}
declare type DeepReadonlyObject<T> = {
    readonly [P in keyof T]: DeepReadonly<T[P]>;
};
declare type DeepReadonly<T> = T extends (infer R)[] ? DeepReadonlyArray<R> : T extends Function ? T : T extends object ? DeepReadonlyObject<T> : T;

declare type DataType<T extends AbstractField<any, any, any> | CombinedField<any>> = T extends AbstractField<infer N, infer RT, infer A> ? DeepReadonly<{
    [k in N]: A extends true ? RT[] : RT;
}> : T extends CombinedField<infer RT> ? DeepReadonly<RT> : never;

interface GraphQlResponse {
    errors: string | Error | Error[];
    data: unknown;
}
declare type Middleware = (response: GraphQlResponse) => unknown;
declare type RequestOptions = {
    endpoint: string;
    headers?: Record<string, string>;
} & Omit<RequestInit, 'method' | 'body' | 'headers'>;
declare const defaultOptions: RequestOptions;
declare class Client {
    protected options: RequestOptions;
    setEndpoint: (endpoint: string) => void;
    setHeaders: (headers: Record<string, string>) => void;
    getOptions: () => RequestOptions;
    post<N extends string, RT, A extends boolean>(rawField: Query<N, RT, A> | Mutation<N, RT, A>, overrideOptions?: Partial<RequestOptions>): Promise<DataType<typeof rawField>>;
    post<RT>(rawField: CombinedField<RT>, overrideOptions?: Partial<RequestOptions>): Promise<DataType<typeof rawField>>;
    /**
     * Handles calculating and transforming fields on result
     */
    protected process(field: AbstractField<any, any, any>, result: any, parentResult: any): Promise<void>;
}

declare const checkForErrors: (res: GraphQlResponse) => unknown | never;
interface IError {
    message: string;
}
declare const parseError: (error: string | IError | IError[]) => string;
declare const parseResponse: (response: GraphQlResponse) => any;

declare const processHeaders: (headers: any, options: RequestOptions) => any;
declare const postFetch: (query: string, variables: GraphQLDocument['variables'], options: RequestOptions) => Promise<Response>;
declare const executePost: (queryObject: GraphQLDocument, options: RequestOptions) => Promise<Response>;

declare const deepApply: (fn: (obj: any) => any, obj: any) => void;

declare const client: Client;

export { AbstractField, Argument, Client, CombinedField, DataType, DeepReadonly, DeepReadonlyArray, DeepReadonlyObject, FetchedFieldItemType, Field, FieldDescendantStore, GraphQLDocument, GraphQlRequestType, GraphQlResponse, HigherKindType, IRequestable, InlineFragment, Middleware, Mutation, Query, RequestOptions, checkForErrors, client, deepApply, defaultOptions, executePost, parseError, parseResponse, postFetch, prepareFieldString, prepareRequest, processHeaders };
