{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { parser } from \"../parser/index.js\";\nimport { Mutation } from \"../components/index.js\";\nimport { defaultMapPropsToOptions, getDisplayName, calculateVariablesFromProps, GraphQLBase } from \"./hoc-utils.js\";\nexport function withMutation(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.alias,\n      alias = _b === void 0 ? 'Apollo' : _b;\n  var mapPropsToOptions = options;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = function () {\n    return options;\n  };\n  return function (WrappedComponent) {\n    var graphQLDisplayName = \"\".concat(alias, \"(\").concat(getDisplayName(WrappedComponent), \")\");\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      GraphQL.prototype.render = function () {\n        var props = this.props;\n        var opts = mapPropsToOptions(props);\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance\n          });\n        }\n\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return React.createElement(Mutation, __assign({\n          ignoreResults: true\n        }, opts, {\n          mutation: document\n        }), function (mutate, _a) {\n          var _b, _c;\n\n          var data = _a.data,\n              r = __rest(_a, [\"data\"]);\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'mutate';\n          var resultName = operationOptions.name ? \"\".concat(name, \"Result\") : 'result';\n          var childProps = (_b = {}, _b[name] = mutate, _b[resultName] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = mutate, _c[resultName] = result, _c.ownProps = props, _c);\n            childProps = operationOptions.props(newResult);\n          }\n\n          return React.createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}","map":{"version":3,"mappings":"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","names":["React","hoistNonReactStatics","parser","Mutation","defaultMapPropsToOptions","getDisplayName","calculateVariablesFromProps","GraphQLBase","withMutation","document","operationOptions","operation","_a","_b","alias","mapPropsToOptions","options","WrappedComponent","graphQLDisplayName","concat","__extends","GraphQL","props","opts","withRef","Object","assign","ref","setWrappedInstance","variables","length","__assign","ignoreResults","mutation","mutate","r","result","data","name","resultName","childProps","newResult","_c"],"sources":["/Users/kacperkondracki/Desktop/TOP/REACT/scandiweb/node_modules/@apollo/src/react/hoc/mutation-hoc.tsx"],"sourcesContent":["import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from '../parser';\nimport { DefaultContext } from '../../core/types';\nimport {\n  BaseMutationOptions,\n  MutationFunction,\n  MutationResult\n} from '../types/types';\nimport { Mutation } from '../components';\n\nimport {\n  defaultMapPropsToOptions,\n  getDisplayName,\n  calculateVariablesFromProps,\n  GraphQLBase\n} from './hoc-utils';\nimport { OperationOption, OptionProps, MutateProps } from './types';\nimport { ApolloCache } from '../../core';\n\nexport function withMutation<\n  TProps extends TGraphQLVariables | {} = {},\n  TData extends Record<string, any> = {},\n  TGraphQLVariables = {},\n  TChildProps = MutateProps<TData, TGraphQLVariables>,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<\n    TProps,\n    TData,\n    TGraphQLVariables,\n    TChildProps\n  > = {}\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n\n  const {\n    options = defaultMapPropsToOptions,\n    alias = 'Apollo'\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => BaseMutationOptions<TData, TGraphQLVariables, TContext, TCache>;\n  if (typeof mapPropsToOptions !== 'function')\n    mapPropsToOptions = () => options as BaseMutationOptions<TData, TGraphQLVariables, TContext, TCache>;\n\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n      render() {\n        let props = this.props as TProps;\n        const opts = mapPropsToOptions(props) as BaseMutationOptions<TData, TGraphQLVariables, TContext, TCache>;\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance\n          });\n        }\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props) as TGraphQLVariables;\n        }\n\n        return (\n          <Mutation ignoreResults {...opts} mutation={document}>\n            {(\n              mutate: MutationFunction<TData, TGraphQLVariables>,\n              { data, ...r }: MutationResult<TData>\n            ) => {\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Mutation component's shape here to replicate that\n              // this matches the query HoC\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'mutate';\n              const resultName = operationOptions.name\n                ? `${name}Result`\n                : 'result';\n              let childProps = ({\n                [name]: mutate,\n                [resultName]: result\n              } as any) as TChildProps;\n              if (operationOptions.props) {\n                const newResult: OptionProps<\n                  TProps,\n                  TData,\n                  TGraphQLVariables\n                > = {\n                  [name]: mutate,\n                  [resultName]: result,\n                  ownProps: props\n                };\n                childProps = operationOptions.props(newResult) as any;\n              }\n\n              return <WrappedComponent {...props} {...childProps} />;\n            }}\n          </Mutation>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n"]},"metadata":{},"sourceType":"module"}